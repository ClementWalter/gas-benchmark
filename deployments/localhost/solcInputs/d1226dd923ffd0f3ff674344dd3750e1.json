{
  "language": "Solidity",
  "sources": {
    "contracts/tokens/ERC721Naomsa.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.8.0 <0.9.0;\n\n/**\n * @title ERC721\n * @author naomsa <https://twitter.com/naomsa666>\n * @notice A complete ERC721 implementation including metadata and enumerable\n * functions. Completely gas optimized and extensible.\n */\ncontract ERC721Naomsa {\n    /*         _           _            */\n    /*        ( )_        ( )_          */\n    /*    ___ | ,_)   _ _ | ,_)   __    */\n    /*  /',__)| |   /'__` )| |   /'__`\\  */\n    /*  \\__, \\| |_ ( (_| || |_ (  ___/  */\n    /*  (____/`\\__)`\\__,_)`\\__)`\\____)  */\n\n    /// @notice See {ERC721-Transfer}.\n    event Transfer(\n        address indexed _from,\n        address indexed _to,\n        uint256 indexed _tokenId\n    );\n    /// @notice See {ERC721-Approval}.\n    event Approval(\n        address indexed _owner,\n        address indexed _approved,\n        uint256 indexed _tokenId\n    );\n    /// @notice See {ERC721-ApprovalForAll}.\n    event ApprovalForAll(\n        address indexed _owner,\n        address indexed _operator,\n        bool _approved\n    );\n\n    /// @notice See {ERC721Metadata-name}.\n    string public name;\n    /// @notice See {ERC721Metadata-symbol}.\n    string public symbol;\n\n    /// @notice See {ERC721Enumerable-totalSupply}.\n    uint256 public totalSupply;\n\n    /// @notice Array of all owners.\n    address[] private _owners;\n    /// @notice Mapping of all balances.\n    mapping(address => uint256) private _balanceOf;\n    /// @notice Mapping from token Id to it's approved address.\n    mapping(uint256 => address) private _tokenApprovals;\n    /// @notice Mapping of approvals between owner and operator.\n    mapping(address => mapping(address => bool)) private _isApprovedForAll;\n\n    /*   _                            */\n    /*  (_ )                _         */\n    /*   | |    _      __  (_)   ___  */\n    /*   | |  /'_`\\  /'_ `\\| | /'___) */\n    /*   | | ( (_) )( (_) || |( (___  */\n    /*  (___)`\\___/'`\\__  |(_)`\\____) */\n    /*              ( )_) |           */\n    /*               \\___/'           */\n\n    constructor(string memory name_, string memory symbol_) {\n        name = name_;\n        symbol = symbol_;\n    }\n\n    function safeMintBatch(address _to, uint256[] memory _ids) public {\n        require(_to != address(0));\n        require(_ids.length > 0);\n        for (uint256 i = 0; i < _ids.length; i++) {\n            _safeMint(_to, _ids[i]);\n        }\n    }\n\n    /// @notice See {ERC721-balanceOf}.\n    function balanceOf(address account_) public view virtual returns (uint256) {\n        require(\n            account_ != address(0),\n            \"ERC721: balance query for the zero address\"\n        );\n        return _balanceOf[account_];\n    }\n\n    /// @notice See {ERC721-ownerOf}.\n    function ownerOf(uint256 tokenId_) public view virtual returns (address) {\n        require(_exists(tokenId_), \"ERC721: query for nonexistent token\");\n        address owner = _owners[tokenId_];\n        return owner;\n    }\n\n    /// @notice See {ERC721Metadata-tokenURI}.\n    function tokenURI(uint256) public view returns (string memory) {\n        return \"\";\n    }\n\n    /// @notice See {ERC721-approve}.\n    function approve(address to_, uint256 tokenId_) public virtual {\n        address owner = ownerOf(tokenId_);\n        require(to_ != owner, \"ERC721: approval to current owner\");\n\n        require(\n            msg.sender == owner || _isApprovedForAll[owner][msg.sender],\n            \"ERC721: caller is not owner nor approved for all\"\n        );\n\n        _approve(to_, tokenId_);\n    }\n\n    /// @notice See {ERC721-getApproved}.\n    function getApproved(uint256 tokenId_)\n        public\n        view\n        virtual\n        returns (address)\n    {\n        require(_exists(tokenId_), \"ERC721: query for nonexistent token\");\n        return _tokenApprovals[tokenId_];\n    }\n\n    /// @notice See {ERC721-setApprovalForAll}.\n    function setApprovalForAll(address operator_, bool approved_)\n        public\n        virtual\n    {\n        _setApprovalForAll(msg.sender, operator_, approved_);\n    }\n\n    /// @notice See {ERC721-isApprovedForAll}.\n    function isApprovedForAll(address account_, address operator_)\n        public\n        view\n        virtual\n        returns (bool)\n    {\n        return _isApprovedForAll[account_][operator_];\n    }\n\n    /// @notice See {ERC721-transferFrom}.\n    function transferFrom(\n        address from_,\n        address to_,\n        uint256 tokenId_\n    ) public virtual {\n        require(\n            _isApprovedOrOwner(msg.sender, tokenId_),\n            \"ERC721: transfer caller is not owner nor approved\"\n        );\n        _transfer(from_, to_, tokenId_);\n    }\n\n    /// @notice See {ERC721-safeTransferFrom}.\n    function safeTransferFrom(\n        address from_,\n        address to_,\n        uint256 tokenId_\n    ) public virtual {\n        safeTransferFrom(from_, to_, tokenId_, \"\");\n    }\n\n    /// @notice See {ERC721-safeTransferFrom}.\n    function safeTransferFrom(\n        address from_,\n        address to_,\n        uint256 tokenId_,\n        bytes memory data_\n    ) public virtual {\n        require(\n            _isApprovedOrOwner(msg.sender, tokenId_),\n            \"ERC721: transfer caller is not owner nor approved\"\n        );\n        _safeTransfer(from_, to_, tokenId_, data_);\n    }\n\n    /// @notice See {ERC721Enumerable.tokenOfOwnerByIndex}.\n    function tokenOfOwnerByIndex(address account_, uint256 index_)\n        public\n        view\n        returns (uint256 tokenId)\n    {\n        require(\n            index_ < balanceOf(account_),\n            \"ERC721Enumerable: Index out of bounds\"\n        );\n        uint256 count;\n        for (uint256 i; i < _owners.length; ++i) {\n            if (account_ == _owners[i]) {\n                if (count == index_) return i;\n                else count++;\n            }\n        }\n        revert(\"ERC721Enumerable: Index out of bounds\");\n    }\n\n    /// @notice See {ERC721Enumerable.tokenByIndex}.\n    function tokenByIndex(uint256 index_)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        require(\n            index_ < _owners.length,\n            \"ERC721Enumerable: Index out of bounds\"\n        );\n        return index_;\n    }\n\n    /// @notice Returns a list of all token Ids owned by `owner`.\n    function walletOfOwner(address account_)\n        public\n        view\n        returns (uint256[] memory)\n    {\n        uint256 balance = balanceOf(account_);\n        uint256[] memory ids = new uint256[](balance);\n        for (uint256 i = 0; i < balance; i++) {\n            ids[i] = tokenOfOwnerByIndex(account_, i);\n        }\n        return ids;\n    }\n\n    /*             _                               _    */\n    /*   _        ( )_                            (_ )  */\n    /*  (_)  ___  | ,_)   __   _ __   ___     _ _  | |  */\n    /*  | |/' _ `\\| |   /'__`\\( '__)/' _ `\\ /'__` ) | |  */\n    /*  | || ( ) || |_ (  ___/| |   | ( ) |( (_| | | |  */\n    /*  (_)(_) (_)`\\__)`\\____)(_)   (_) (_)`\\__,_)(___) */\n\n    /**\n     * @notice Safely transfers `tokenId_` token from `from_` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     */\n    function _safeTransfer(\n        address from_,\n        address to_,\n        uint256 tokenId_,\n        bytes memory data_\n    ) internal virtual {\n        _transfer(from_, to_, tokenId_);\n        _checkOnERC721Received(from_, to_, tokenId_, data_);\n    }\n\n    /// @notice Returns whether `tokenId_` exists.\n    function _exists(uint256 tokenId_) internal view virtual returns (bool) {\n        return tokenId_ < _owners.length && _owners[tokenId_] != address(0);\n    }\n\n    /// @notice Returns whether `spender_` is allowed to manage `tokenId`.\n    function _isApprovedOrOwner(address spender_, uint256 tokenId_)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        require(_exists(tokenId_), \"ERC721: query for nonexistent token\");\n        address owner = _owners[tokenId_];\n        return (spender_ == owner ||\n            getApproved(tokenId_) == spender_ ||\n            isApprovedForAll(owner, spender_));\n    }\n\n    /// @notice Safely mints `tokenId_` and transfers it to `to`.\n    function _safeMint(address to_, uint256 tokenId_) internal virtual {\n        _safeMint(to_, tokenId_, \"\");\n    }\n\n    /**\n     * @notice Same as {_safeMint}, but with an additional `data_` parameter which is\n     * forwarded in {ERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to_,\n        uint256 tokenId_,\n        bytes memory data_\n    ) internal virtual {\n        _mint(to_, tokenId_);\n        _checkOnERC721Received(address(0), to_, tokenId_, data_);\n    }\n\n    /// @notice Mints `tokenId_` and transfers it to `to_`.\n    function _mint(address to_, uint256 tokenId_) internal virtual {\n        require(!_exists(tokenId_), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to_, tokenId_);\n\n        _owners.push(to_);\n        totalSupply++;\n        unchecked {\n            _balanceOf[to_]++;\n        }\n\n        emit Transfer(address(0), to_, tokenId_);\n        _afterTokenTransfer(address(0), to_, tokenId_);\n    }\n\n    /// @notice Destroys `tokenId`. The approval is cleared when the token is burned.\n    function _burn(uint256 tokenId_) internal virtual {\n        address owner = ownerOf(tokenId_);\n\n        _beforeTokenTransfer(owner, address(0), tokenId_);\n\n        // Clear approvals\n        _approve(address(0), tokenId_);\n        delete _owners[tokenId_];\n        totalSupply--;\n        _balanceOf[owner]--;\n\n        emit Transfer(owner, address(0), tokenId_);\n        _afterTokenTransfer(owner, address(0), tokenId_);\n    }\n\n    /// @notice Transfers `tokenId_` from `from_` to `to`.\n    function _transfer(\n        address from_,\n        address to_,\n        uint256 tokenId_\n    ) internal virtual {\n        require(\n            _owners[tokenId_] == from_,\n            \"ERC721: transfer of token that is not own\"\n        );\n\n        _beforeTokenTransfer(from_, to_, tokenId_);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId_);\n\n        _owners[tokenId_] = to_;\n        unchecked {\n            _balanceOf[from_]--;\n            _balanceOf[to_]++;\n        }\n\n        emit Transfer(from_, to_, tokenId_);\n        _afterTokenTransfer(from_, to_, tokenId_);\n    }\n\n    /// @notice Approve `to_` to operate on `tokenId_`\n    function _approve(address to_, uint256 tokenId_) internal virtual {\n        _tokenApprovals[tokenId_] = to_;\n        emit Approval(_owners[tokenId_], to_, tokenId_);\n    }\n\n    /// @notice Approve `operator_` to operate on all of `account_` tokens.\n    function _setApprovalForAll(\n        address account_,\n        address operator_,\n        bool approved_\n    ) internal virtual {\n        require(account_ != operator_, \"ERC721: approve to caller\");\n        _isApprovedForAll[account_][operator_] = approved_;\n        emit ApprovalForAll(account_, operator_, approved_);\n    }\n\n    /// @notice ERC721Receiver callback checking and calling helper.\n    function _checkOnERC721Received(\n        address from_,\n        address to_,\n        uint256 tokenId_,\n        bytes memory data_\n    ) private {\n        if (to_.code.length > 0) {\n            try\n                IERC721Receiver(to_).onERC721Received(\n                    msg.sender,\n                    from_,\n                    tokenId_,\n                    data_\n                )\n            returns (bytes4 returned) {\n                require(\n                    returned == 0x150b7a02,\n                    \"ERC721: safe transfer to non ERC721Receiver implementation\"\n                );\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\n                        \"ERC721: safe transfer to non ERC721Receiver implementation\"\n                    );\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n\n    /// @notice Hook that is called before any token transfer.\n    function _beforeTokenTransfer(\n        address from_,\n        address to_,\n        uint256 tokenId_\n    ) internal virtual {}\n\n    /// @notice Hook that is called after any token transfer.\n    function _afterTokenTransfer(\n        address from_,\n        address to_,\n        uint256 tokenId_\n    ) internal virtual {}\n\n    /*    ___  _   _  _ _      __   _ __  */\n    /*  /',__)( ) ( )( '_`\\  /'__`\\( '__) */\n    /*  \\__, \\| (_) || (_) )(  ___/| |    */\n    /*  (____/`\\___/'| ,__/'`\\____)(_)    */\n    /*               | |                  */\n    /*               (_)                  */\n\n    /// @notice See {IERC165-supportsInterface}.\n    function supportsInterface(bytes4 interfaceId_)\n        public\n        view\n        virtual\n        returns (bool)\n    {\n        return\n            interfaceId_ == 0x80ac58cd || // ERC721\n            interfaceId_ == 0x5b5e139f || // ERC721Metadata\n            interfaceId_ == 0x780e9d63 || // ERC721Enumerable\n            interfaceId_ == 0x01ffc9a7;\n        // ERC165\n    }\n}\n\ninterface IERC721Receiver {\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes memory data\n    ) external returns (bytes4);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 2000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}